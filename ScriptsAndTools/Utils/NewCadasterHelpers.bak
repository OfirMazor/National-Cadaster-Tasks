from Utils.Configs import CNFG
from Utils.Helpers import get_ProcessGUID, get_RecordGUID, get_BlockGUID, start_editing, stop_editing, get_layer, reopen_map, Type2CreateType, timestamp
from arcpy.management import Append, GetCount, SelectLayerByAttribute as SelectByAttribute, SelectLayerByLocation as SelectByLocation, CalculateField, Delete
from arcpy.da import SearchCursor, UpdateCursor
from arcpy import AddMessage, AddWarning, AddError,env as ENV, Describe, Extent
from arcpy.mp import LayerFile, ArcGISProject
from arcpy.mp import ArcGISProject

def update_settled_block_geometry(processName:str) -> None:
    ''' 
    Updating current block's data (Shape,LastSetteledParcel,CreatedByRecord,BlockStatus,LandType)

    '''
    

    Process_border_layer = get_layer('גבול תכנית')
    Block_layer = get_layer('גוש הסדר')

    editor = start_editing(CNFG.ParcelFabricDatabase)
    

   
    # Get the single feature from Process_border_layer
    with SearchCursor(Process_border_layer, field_names="SHAPE@") as cursor:
        process_geometry = cursor.next()[0]



    is_updated = False
    # Update the CreatedByRecord, LandType, and BlockStatus fields in the single feature of the Block_layer
    with UpdateCursor(Block_layer, ["SHAPE@","CreatedByRecord", "LandType", "BlockStatus", "LastSetteledParcel"]) as cursor:
        row = next(cursor, None)  # Safely get the first row or None
        if row:
            row[0] = process_geometry      # SHAPE@
            cursor.updateRow(row)
            is_updated = True


    if is_updated:

        AddMessage(f'                Geometry was updated')

    else:
        AddWarning(f'                Was unable to update the block\'s geometry')

    stop_editing(editor)




def layer_exists(layer_name)-> bool:
    """
    Check if a layer with the given name exists in the current map.

    Parameters:
        layer_name (str): The name of the layer to check.

    Returns:
        bool: True if the layer exists, False otherwise.
    """
    # Get the current ArcGIS Pro project
    aprx = ArcGISProject("CURRENT")
    
    # Get the active map
    active_map = aprx.activeMap
    if active_map is None:
        raise ValueError("No active map found.")
    
    # Check for the layer in the active map
    for layer in active_map.listLayers():
        if layer.name == layer_name:
            return True
    
    return False


def print_empty_layers(layers_list:list, layers_type:str = 'required' or 'not required') -> None:
    '''
    Prints a list of empty layers with an appropriate message

    Parameters:
        layers_list (list): A list of empty layers.
        layers_type (str): The type of layers, required or not required. 
                            For the required layers an error message will be printed.
    Returns:
        None
    '''
    if layers_list:
        for layer in layers_list:
            if layers_type == 'required':
                AddError(f'                 • The required layer {layer} is empty. Check in-Process data')
            else: # layers_type == 'not required'
                AddMessage(f"                   • No {layer} were found")

def count_features_in_group(group_layer, required_layers:list = None) -> None:
    '''
    Counts features in a group layer, prints the results and deletes empty layers.
    There is an option to pass a list of required layers that will be checked for features existence
        and if empty, an error message will be printed

    Parameters:
        group_layer (GroupLayer): The group layer to count features in.
        required_layers (list): An optional list of required layers to check for features existence.
    Returns:
        None
    '''

    if group_layer and group_layer.isGroupLayer:
        AddMessage(f'{timestamp()} | ✴️ The layers group {group_layer.name} was created. Counting features:') 

        inprocess_points = get_layer('נקודות בתהליך')
        inprocess_fronts = get_layer('חזיתות בתהליך')

        empty_non_required_layers = []
        empty_required_layers = []
        for layer in group_layer.listLayers():
            if not layer.isGroupLayer:


                # There is a bug and the GetCount function won't properly count features in 4 of the layers
                #   so to bypass it, using combination of definition query retrieval and SelectByAttribute from the main layers 
                #   to get the correct features count for these layers
                
                if layer.name in ['נקודות ביסוס','נקודות חדשות']:
                    def_query = layer.definitionQuery
                    SelectByAttribute(inprocess_points,where_clause=def_query,selection_type='NEW_SELECTION')
                    feature_count = int(GetCount(inprocess_points).getOutput(0))
                    SelectByAttribute(inprocess_points, "CLEAR_SELECTION")
                elif layer.name in ['חזיתות ביסוס','חזיתות חדשות']:
                    def_query = layer.definitionQuery
                    SelectByAttribute(inprocess_fronts,where_clause=def_query,selection_type='NEW_SELECTION')
                    feature_count = int(GetCount(inprocess_fronts).getOutput(0))
                    SelectByAttribute(inprocess_fronts, "CLEAR_SELECTION")
                else:
                    feature_count = int(GetCount(layer).getOutput(0))

                if feature_count > 0: # looking for larger than 0 because it could be -1 when it has a wrong (empty) definition query
                    AddMessage(f"                   • The layer {layer.name} has {feature_count} features")
                elif layer.name not in required_layers:
                    empty_non_required_layers.append(layer.name)
                    #AddMessage(f"                   • No {layer.name} were found")
                    Delete(layer)
                else:
                    empty_required_layers.append(layer.name)
                    #AddError(f'                 • The required layer {layer.name} is empty. Check in-Process data')

        
            else:
                print_empty_layers(empty_non_required_layers, 'not required')
                print_empty_layers(empty_required_layers, 'required')
                AddMessage(f"               The subgroup {layer.name}:")
                empty_non_required_layers = []
                empty_required_layers = []
        print_empty_layers(empty_non_required_layers, 'not required')
        print_empty_layers(empty_required_layers, 'required')

        
        del [inprocess_points,inprocess_fronts]

    else:
        AddError(f'{timestamp()} | ⚠️ The group layer {group_layer.name} was not created. Check the data and the existance of a proper *.lyrx file')



def set_environment_extent(ProcessName:str, buffer_dist:int = 30) -> None:
    '''
    Sets the environment extent to the extent of the process borders layer with an optional addition of a buffer distance
    The extent is a rectangle defined by a pair of coordinates: the lower-left corner and the upper-right corner

    Parameters:
        ProcessName (str): The name of the process
        buffer_dist (int): The buffer distance in meters that will be added to the upper-right corner 
                            and subtracted from the lower-left corner of the extent (both X and Y)

    Returns:
        None
    '''
    process_borders = get_layer('גבולות תהליכי קדסטר')
    ProcessGUID = get_ProcessGUID(ProcessName)
    process_border = SelectByAttribute(process_borders,where_clause=f""" GlobalID = '{ProcessGUID}' """,selection_type='NEW_SELECTION')

    layer_desc = Describe(process_border)
    layer_extent = layer_desc.extent
    
    expanded_extent = Extent(
        layer_extent.XMin - buffer_dist,
        layer_extent.YMin - buffer_dist,
        layer_extent.XMax + buffer_dist,
        layer_extent.YMax + buffer_dist,
    )

    ENV.extent = expanded_extent

    SelectByAttribute(process_borders, "CLEAR_SELECTION")
    del [process_border,process_borders,layer_desc,layer_extent,expanded_extent]


def update_connections(TaskType:str = 'CreateNewCadaster' or 'ImproveNewCadaster') -> None:
    '''
        Updates layers' source from default to the current version

        Parameters:
        TaskType (str): The Task's type, CreateNewCadaster or ImproveNewCadaster

        Returns:
            None
    '''
    
    if TaskType == 'CreateNewCadaster':
        CONNECTION_PROPERTIES_MAP = {
            "גושים": ["גוש הסדר","גושים לא מוסדרים", "גושים מוסדרים"],
            "חלקות": ["חלקות לא מוסדרות", "חלקות מוסדרות"],
            "נקודות גבול": ["נקודות גבול קיימות"],
            "חזיתות": ["חזיתות קיימות"]
        }
    else:
        CONNECTION_PROPERTIES_MAP = {
            "גושים": ["גושים לא מוסדרים", "גושים מוסדרים"],
            "חלקות": ["חלקות לא מוסדרות", "חלקות מוסדרות"],
            "נקודות גבול": ["נקודות גבול קיימות"],
            "חזיתות": ["חזיתות קיימות"]
        }

    
    for base_layer_name, target_layers in CONNECTION_PROPERTIES_MAP.items():

        base_conn = get_layer(base_layer_name).connectionProperties

        for target_layer_name in target_layers:
            target_layer = get_layer(target_layer_name)
            target_layer.updateConnectionProperties(target_layer.connectionProperties, base_conn)


    reopen_map()

def filter_process_layers_group(ProcessName:str, TaskType:str = 'CreateNewCadaster' or 'ImproveNewCadaster',search_distance:int="10") -> None:
    '''
    Filters the layers in the process layers\'s group based on the process borders layer, the task type and the search distance

    Parameters:
        ProcessName (str): The name of the process
        TaskType (str): The Task's type, CreateNewCadaster or ImproveNewCadaster
        search_distance (int): The search distance in meters to be used while looking for intersecting features using SelectByLocation 

    Returns:
        None
    '''

    ProcessGUID = get_ProcessGUID(ProcessName)


    if TaskType == 'CreateNewCadaster':

        BlockGUID = get_BlockGUID('ProcessName',ProcessName)
        settled_blocks_query = f"""LandType=1 AND RetiredByRecord IS NULL AND GlobalID <> '{BlockGUID}'"""
        unsettled_blocks_query = f"""LandType=2 AND RetiredByRecord IS NULL AND GlobalID <> '{BlockGUID}'"""
        new_points_layer = get_layer('נקודות חדשות')
        new_fronts_layer = get_layer('חזיתות חדשות')
        process_parcels_layer = get_layer('חלקות ביסוס')
        settled_block_layer = get_layer('גוש הסדר')

        process_parcels_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" CPBUniqueID = '{ProcessGUID}' """, 'isActive':True}])
        settled_block_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID = '{BlockGUID}' """, 'isActive':True}]) 

    else: #TaskType == 'ImproveNewCadaster'
        settled_blocks_query = f"""LandType=1 AND RetiredByRecord IS NULL"""
        unsettled_blocks_query = f"""LandType=2 AND RetiredByRecord IS NULL"""

    in_process_fronts_layer = get_layer('חזיתות בתהליך')
    in_process_points_layer = get_layer('נקודות בתהליך')
    blocks_layer = get_layer('גושים')
    border_points_layer = get_layer('נקודות גבול')
    fronts_layer = get_layer('חזיתות')
    current_process_border_layer = get_layer('גבול תכנית')
    process_base_points_layer = get_layer('נקודות ביסוס')
    process_base_fronts_layer = get_layer('חזיתות ביסוס')
    neighboring_existing_points_layer = get_layer('נקודות גבול קיימות')
    neighboring_existing_fronts_layer = get_layer('חזיתות קיימות')
    neighboring_settled_parcels_layer = get_layer('חלקות מוסדרות')
    neighboring_settled_blocks_layer = get_layer('גושים מוסדרים')
    neighboring_unsettled_parcels_layer = get_layer('חלקות לא מוסדרות')
    neighboring_unsettled_blocks_layer = get_layer('גושים לא מוסדרים')

    current_process_border_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID = '{ProcessGUID}' """, 'isActive':True}])   
    
    # may be needed later
    #if TaskType == 'CreateNewCadaster':
    #    update_settled_block_geometry(ProcessName)
 
    update_connections(TaskType)



    all_settled_blocks = SelectByAttribute(blocks_layer,where_clause=settled_blocks_query,selection_type='NEW_SELECTION')
    intersecting_settled_blocks = SelectByLocation(all_settled_blocks,'INTERSECT',select_features=current_process_border_layer,search_distance=f"{search_distance} Meters",selection_type="SUBSET_SELECTION")
    query = [row[0] for row in SearchCursor(intersecting_settled_blocks, 'GlobalID')]
    joined_string = ",".join(f"'{uniqueID}'" for uniqueID in query)
    sql_list = f"({joined_string})"

    neighboring_settled_blocks_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID IN {sql_list} """, 'isActive':True}])   
    neighboring_settled_parcels_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" BlockUniqueID IN {sql_list} And RetiredByRecord IS NULL """, 'isActive':True}]) 


    SelectByAttribute(blocks_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)
    
    all_unsettled_blocks = SelectByAttribute(blocks_layer,where_clause=unsettled_blocks_query,selection_type='NEW_SELECTION')
    intersecting_unsettled_blocks = SelectByLocation(all_unsettled_blocks,'INTERSECT',select_features=current_process_border_layer,search_distance=f"{search_distance} Meters",selection_type="SUBSET_SELECTION")
    query = [row[0] for row in SearchCursor(intersecting_unsettled_blocks, 'GlobalID')]
    joined_string = ",".join(f"'{uniqueID}'" for uniqueID in query)
    sql_list = f"({joined_string})"
    

    neighboring_unsettled_blocks_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID IN {sql_list} AND RetiredByRecord IS NULL""", 'isActive':True}])   
    neighboring_unsettled_parcels_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" BlockUniqueID IN {sql_list} And RetiredByRecord IS NULL """, 'isActive':True}]) 

    
    SelectByAttribute(blocks_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)

    all_process_points = SelectByAttribute(in_process_points_layer,where_clause=f"""CPBUniqueID = '{ProcessGUID}'""",selection_type='NEW_SELECTION')
    external_process_points = SelectByLocation(in_layer=all_process_points,overlap_type="BOUNDARY_TOUCHES",select_features=current_process_border_layer,search_distance=None,selection_type="SUBSET_SELECTION")
    query = [row[0] for row in SearchCursor(external_process_points, 'GlobalID')]
    joined_string = ",".join(f"'{uniqueID}'" for uniqueID in query)
    sql_list = f"({joined_string})"
    process_base_points_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID IN {sql_list} """, 'isActive':True}])   
    if TaskType == 'CreateNewCadaster':
        SelectByAttribute(in_process_points_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)
        new_points_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID NOT IN {sql_list} AND CPBUniqueID = '{ProcessGUID}' """, 'isActive':True}])   
    SelectByAttribute(in_process_points_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)



    all_process_fronts = SelectByAttribute(in_process_fronts_layer,where_clause=f"""CPBUniqueID = '{ProcessGUID}'""",selection_type='NEW_SELECTION')
    external_process_fronts = SelectByLocation(in_layer=all_process_fronts,overlap_type="SHARE_A_LINE_SEGMENT_WITH",select_features=current_process_border_layer,search_distance=None,selection_type="SUBSET_SELECTION")
    query = [row[0] for row in SearchCursor(external_process_fronts, 'GlobalID')]
    joined_string = ",".join(f"'{uniqueID}'" for uniqueID in query)
    sql_list = f"({joined_string})"
    process_base_fronts_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID IN {sql_list} """, 'isActive':True}]) 
    if TaskType == 'CreateNewCadaster':
        SelectByAttribute(in_process_fronts_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)
        new_fronts_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID NOT IN {sql_list} AND CPBUniqueID = '{ProcessGUID}' """, 'isActive':True}])   
    SelectByAttribute(in_process_fronts_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)


    
    intersecting_points = SelectByLocation(border_points_layer,'INTERSECT',select_features=current_process_border_layer,search_distance=f"{search_distance} Meters",selection_type='NEW_SELECTION')
    query = [row[0] for row in SearchCursor(intersecting_points, 'GlobalID')]
    joined_string = ",".join(f"'{uniqueID}'" for uniqueID in query)
    sql_list = f"({joined_string})"

    neighboring_existing_points_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID IN {sql_list} AND RetiredByRecord IS NULL""", 'isActive':True}])     

    
    SelectByAttribute(border_points_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)

    
    intersecting_fronts = SelectByLocation(fronts_layer,'INTERSECT',select_features=current_process_border_layer,search_distance=f"{search_distance} Meters",selection_type='NEW_SELECTION')
    query = [row[0] for row in SearchCursor(intersecting_fronts, 'GlobalID')]
    joined_string = ",".join(f"'{uniqueID}'" for uniqueID in query)
    sql_list = f"({joined_string})"

    neighboring_existing_fronts_layer.updateDefinitionQueries([{'name':'Query 1', 'sql':f""" GlobalID IN {sql_list} AND RetiredByRecord IS NULL""", 'isActive':True}])     



    SelectByAttribute(fronts_layer,selection_type="CLEAR_SELECTION",where_clause="",invert_where_clause=None)


    del [all_settled_blocks,intersecting_settled_blocks,all_process_points,external_process_points,all_process_fronts,external_process_fronts,
        intersecting_points,intersecting_fronts,process_base_fronts_layer, process_base_points_layer, current_process_border_layer,fronts_layer, 
        neighboring_settled_blocks_layer, neighboring_settled_parcels_layer,neighboring_unsettled_parcels_layer,neighboring_unsettled_blocks_layer,
        neighboring_existing_points_layer,neighboring_existing_fronts_layer,in_process_fronts_layer,in_process_points_layer,blocks_layer,border_points_layer]

    if TaskType == 'CreateNewCadaster':
        del [new_points_layer, new_fronts_layer, process_parcels_layer, settled_block_layer]




def update_layer_fields_dict(input_layer, updates_dict, method='UpdateCursor' or 'CalculateField', clear_selection:bool = True, where_clause=None):
    
    num_of_updated_rows = 0
    if clear_selection:
        SelectByAttribute(input_layer, "CLEAR_SELECTION")

    if method == 'UpdateCursor':

        # Extract the field names and corresponding values from the dictionary
        fields_to_update = list(updates_dict.keys())

        # Start an edit session
        editor = start_editing(CNFG.ParcelFabricDatabase)

        try:
            with UpdateCursor(input_layer, fields_to_update, where_clause=where_clause) as cursor:
                for row in cursor:
                    # For each row, update all specified fields
                    for i, field_name in enumerate(fields_to_update):
                        row[i] = updates_dict[field_name]

                    # Update the row
                    cursor.updateRow(row)
                    num_of_updated_rows += 1
        finally:
            # Stop the edit session (commit by default, or roll back if errors occur)
            stop_editing(editor)

    elif method == 'CalculateField':

        # Select matching rows in the existing layer or table view
        if where_clause:
            SelectByAttribute(input_layer,"NEW_SELECTION",where_clause)
        # Loop through each field update and call CalculateField
        for field_name, calc_info in updates_dict.items():

            if isinstance(calc_info, tuple):
                # If the user passed in (expression, code_block)
                expression, code_block = calc_info
            else:
                # Otherwise, treat it as a constant (or string) expression
                # Make sure it's a string if it's numeric, e.g. "1"
                expression = str(calc_info)
                code_block = None

            CalculateField(in_table=input_layer,field=field_name,expression=expression,expression_type="PYTHON3",code_block=code_block)
            num_of_updated_rows += 1

    return num_of_updated_rows

def append_process_to_records(ProcessName:str) -> int:
        
    process_borders_layer = get_layer('גבולות תהליכי קדסטר')
    record_borders_layer  = get_layer('גבולות רישומים')

    field_mapping = fr'Name "שם מפה" true true true 255 Text 0 0,First,#,{process_borders_layer.name},ProcessName,0,100;'+\
                fr'RecordType "סוג תהליך" true true true 4 Long 0 0,First,#,{process_borders_layer.name},ProcessType,-1,-1;'+\
                fr'GeodeticNetwork "רשת בקרה" true true false 2 Short 0 0,First,#,{process_borders_layer.name},GeodeticNetwork,-1,-1;'+\
                fr'Status "סטטוס" true true false 2 Short 0 0,First,#,{process_borders_layer.name},Status,-1,-1;'+\
                fr'SurveyorLicenseID "רשיון מודד" true true false 2 Short 0 0,First,#,{process_borders_layer.name},SurveyorLicenseID,-1,-1;'+\
                fr'DataSource "מקור הנתונים" true true false 2 Short 0 0,First,#,{process_borders_layer.name},DataSource,-1,-1;'+\
                fr'PlanName "תכנית מפורטת" true true false 255 Text 0 0,First,#,{process_borders_layer.name},PlanName,0,255;'+\
                fr'BlockUniqueID "מזהה גוש" true true false 38 Guid 0 0,First,#,{process_borders_layer.name},BlockUniqueID,-1,-1'              


    Append(inputs = process_borders_layer, target = record_borders_layer, expression = f"ProcessName = '{ProcessName}'", field_mapping = field_mapping,
         schema_type = "NO_TEST", subtype = "", match_fields = None, update_geometry = "NOT_UPDATE_GEOMETRY")

    reopen_map()

    SelectByAttribute(record_borders_layer,where_clause=f"Name = '{ProcessName}'",selection_type="NEW SELECTION")
    appended_features_count = int(GetCount(record_borders_layer).getOutput(0))
    SelectByAttribute(record_borders_layer, "CLEAR_SELECTION")

    return appended_features_count

def append_settled_parcels(ProcessName:str) -> tuple[int,int]:

    RecordGUID = get_RecordGUID(ProcessName,'MAP')
    BlockGUID = get_BlockGUID('ProcessName',ProcessName)

    process_parcels_layer = get_layer('חלקות בתהליך')   
    record_parcels_layer = get_layer('חלקות')

    field_mapping = fr'GlobalID "GlobalID" false false true 38 GlobalID 0 0,First,#,{process_parcels_layer.name},GlobalID,-1,-1;'+\
                fr'Name "Name" true true true 255 Text 0 0,Join,"/",{process_parcels_layer.name},ParcelNumber,-1,-1,{process_parcels_layer.name},BlockNumber,-1,-1,{process_parcels_layer.name},SubBlockNumber,-1,-1;'+\
                fr'LandDesignationPlan "יעוד הקרקע" true true false 80 Text 0 0,First,#,{process_parcels_layer.name},LandDesignationPlan,0,79;'+\
                fr'CreatedByRecord "Created By Record" true true true 38 Guid 0 0,First,#;'+\
                fr'RetiredByRecord "Retired By Record" true true true 38 Guid 0 0,First,#;'+\
                fr'StatedArea "Stated Area" true true true 8 Double 0 0,First,#,{process_parcels_layer.name},LegalArea,-1,-1;'+\
                fr'StatedAreaUnit "Stated Area Unit" true true true 4 Long 0 0,First,#;'+\
                fr'CalculatedArea "Calculated Area" true true true 8 Double 0 0,First,#;'+\
                fr'MiscloseRatio "Misclose Ratio" true true true 8 Double 0 0,First,#;'+\
                fr'MiscloseDistance "Misclose Distance" true true true 8 Double 0 0,First,#;'+\
                fr'IsSeed "Is Seed" true true true 4 Long 0 0,First,#;'+\
                fr'ParcelType "סוג החלקה" true true false 2 Short 0 0,First,#,{process_parcels_layer.name},ParcelType,-1,-1;'+\
                fr'CreateProcessType "סוג תהליך יוצר" true true false 2 Short 0 0,First,#,{process_parcels_layer.name},ProcessType,-1,-1;'+\
                fr'ParcelNumber "מספר חלקה" true true false 2 Short 0 0,First,#,{process_parcels_layer.name},ParcelNumber,-1,-1;'+\
                fr'LandType "סוג מקרקעין" true true false 2 Short 0 0,First,#,{process_parcels_layer.name},LandType,-1,-1;'+\
                fr'BlockNumber "מספר גוש" true true false 4 Long 0 0,First,#,{process_parcels_layer.name},BlockNumber,-1,-1;'+\
                fr'SubBlockNumber "מספר תת-גוש" true true false 2 Short 0 0,First,#,{process_parcels_layer.name},SubBlockNumber,-1,-1;'+\
                fr'UpdatedByRecord "מזהה תהליך מעדכן" true true false 38 Guid 0 0,First,#;'+\
                fr'CancelProcessType "סוג תהליך מבטל" true true false 2 Short 0 0,First,#;'+\
                fr'IsTax "שומא" true true false 2 Short 0 0,First,#,{process_parcels_layer.name},IsTax,-1,-1;'+\
                fr'BlockUniqueID "מזהה גוש" true true false 38 Guid 0 0,First,#,{process_parcels_layer.name},BlockUniqueID,-1,-1'
    
    Append(inputs=process_parcels_layer,target=record_parcels_layer,expression = f"BlockUniqueID = '{BlockGUID}'",field_mapping = field_mapping,
        schema_type="NO_TEST",subtype="",match_fields=None,update_geometry="NOT_UPDATE_GEOMETRY")
    
    reopen_map()

    SelectByAttribute(record_parcels_layer,where_clause=f"""BlockUniqueID='{BlockGUID}' AND RetiredByRecord IS NULL""",selection_type="NEW SELECTION")
    appended_features_count = int(GetCount(record_parcels_layer).getOutput(0))
    SelectByAttribute(record_parcels_layer, "CLEAR_SELECTION")
  
    inserted_parcels = SelectByAttribute(record_parcels_layer,where_clause=f"""BlockUniqueID='{BlockGUID}' AND RetiredByRecord IS NULL""",selection_type='NEW_SELECTION')
    calculated_features_count = int(GetCount(inserted_parcels)[0])

    CalculateField(in_table=inserted_parcels,field="CreatedByRecord",expression=f"'{RecordGUID}'",
        expression_type="SQL",code_block="",field_type="TEXT",enforce_domains="NO_ENFORCE_DOMAINS")

    CalculateField(in_table=inserted_parcels,field="LandType",expression="1",
        expression_type="SQL",code_block="",field_type="TEXT",enforce_domains="NO_ENFORCE_DOMAINS")
    
    CalculateField(in_table=inserted_parcels,field="CreateProcessType",expression="3",
        expression_type="SQL",code_block="",field_type="TEXT",enforce_domains="NO_ENFORCE_DOMAINS")
    

    return appended_features_count, calculated_features_count

def append_new_fronts(ProcessName:str, query:str) -> tuple[int,int]:
            
    RecordGUID = get_RecordGUID(ProcessName,'MAP')
    Process_GUID = get_ProcessGUID(ProcessName)

    process_fronts_layer = get_layer('חזיתות בתהליך')
    record_fronts_layer = get_layer('חזיתות')
    

    field_mapping = fr'GlobalID "GlobalID" false false true 38 GlobalID 0 0,First,#,{process_fronts_layer.name},GlobalID,-1,-1;' + \
        fr'CreatedByRecord "Created By Record" true true true 38 Guid 0 0,First,#,{process_fronts_layer.name},CPBUniqueID,-1,-1;' + \
        fr'RetiredByRecord "Retired By Record" true true true 38 Guid 0 0,First,#;' + \
        fr'Direction "Direction" true true true 8 Double 0 0,First,#;' + \
        fr'Distance "Distance" true true true 8 Double 0 0,First,#,{process_fronts_layer.name},LegalLength,-1,-1;' + \
        fr'Radius "Radius" true true true 8 Double 0 0,First,#,{process_fronts_layer.name},Radius,-1,-1;' + \
        fr'ArcLength "Arc Length" true true true 8 Double 0 0,First,#;' + \
        fr'Radius2 "Radius2" true true true 8 Double 0 0,First,#;' + \
        fr'COGOType "COGO Type" true true true 4 Long 0 0,First,#;' + \
        fr'IsCOGOGround "Is COGO Ground" true true true 4 Long 0 0,First,#;' + \
        fr'Rotation "Rotation" true true true 8 Double 0 0,First,#;' + \
        fr'Scale "Scale" true true true 8 Double 0 0,First,#;' + \
        fr'ParentLineID "מזהה חזית קודמת" true true true 38 Guid 0 0,First,#;' + \
        fr'DirectionAccuracy "דיוק כיוון" true true true 8 Double 0 0,First,#;' + \
        fr'DistanceAccuracy "דיוק אורך" true true true 8 Double 0 0,First,#;' + \
        fr'LabelPosition "מיקום תווית" true true true 4 Long 0 0,First,#;' + \
        fr'LineType "סוג הקו" true true false 2 Short 0 0,First,#,{process_fronts_layer.name},LineType,-1,-1;' + \
        fr'StartPointUniqueID "מזהה נקודת התחלה" true true false 38 Guid 0 0,First,#,{process_fronts_layer.name},StartPointUniqueID,-1,-1;' + \
        fr'EndPointUniqueID "מזהה נקודת סיום" true true false 38 Guid 0 0,First,#,{process_fronts_layer.name},EndPointUniqueID,-1,-1'
    
    Append(inputs=process_fronts_layer,target=record_fronts_layer,expression = query,field_mapping = field_mapping,
        schema_type="NO_TEST",subtype="",match_fields=None,update_geometry="NOT_UPDATE_GEOMETRY")

    reopen_map()

    SelectByAttribute(record_fronts_layer,where_clause=f""" CreatedByRecord = '{Process_GUID}' """,selection_type="NEW SELECTION")
    appended_features_count = int(GetCount(record_fronts_layer).getOutput(0))
    SelectByAttribute(record_fronts_layer, "CLEAR_SELECTION")

    inserted_fronts = SelectByAttribute(record_fronts_layer,where_clause=f""" CreatedByRecord = '{Process_GUID}' """,selection_type='NEW_SELECTION')

    calculated_features_count = int(GetCount(inserted_fronts)[0])

    CalculateField(in_table=inserted_fronts,field="CreatedByRecord",expression=f"'{RecordGUID}'",
        expression_type="SQL",code_block="",field_type="TEXT",enforce_domains="NO_ENFORCE_DOMAINS")

    return appended_features_count, calculated_features_count

def append_new_border_points(ProcessName:str,query:str) -> tuple[int, int]:

    RecordGUID = get_RecordGUID(ProcessName,'MAP')
    Process_GUID = get_ProcessGUID(ProcessName)

    process_points_layer = get_layer('נקודות בתהליך')  
    record_points_layer = get_layer('נקודות גבול')

    field_mapping=fr'UpdatedByRecord "מזהה תהליך מעדכן" true true false 38 Guid 0 0,First,#;' + \
        fr'CreatedByRecord "Created By Record" true true true 38 Guid 0 0,First,#,{process_points_layer.name},CPBUniqueID,-1,-1;' + \
        fr'RetiredByRecord "Retired By Record" true true true 38 Guid 0 0,First,#;' + \
        fr'Name "Name" true true true 255 Text 0 0,First,#,{process_points_layer.name},PointName,0,19;' + \
        fr'IsFixed "Fixed Shape" true true true 0 Long 0 0,First,#;' + \
        fr'AdjustmentConstraint "Adjustment Constraint" true true true 0 Long 0 0,First,#;' + \
        fr'Preserve "Preserve" true true true 0 Long 0 0,First,#;' + \
        fr'X "X" true true true 0 Double 0 0,First,#;' + \
        fr'Y "Y" true true true 0 Double 0 0,First,#;' + \
        fr'Z "Z" true true true 0 Double 0 0,First,#;' + \
        fr'XYAccuracy "XY Accuracy" true true true 0 Double 0 0,First,#;' + \
        fr'ZAccuracy "Z Accuracy" true true true 0 Double 0 0,First,#;' + \
        fr'XYUncertainty "XY Uncertainty" true true true 0 Double 0 0,First,#;' + \
        fr'EllipseMajor "Error Ellipse Semi Major" true true true 0 Double 0 0,First,#;' + \
        fr'EllipseMinor "Error Ellipse Semi Minor" true true true 0 Double 0 0,First,#;' + \
        fr'EllipseDirection "Error Ellipse Direction" true true true 0 Double 0 0,First,#;' + \
        fr'GlobalID "GlobalID" false false true 38 GlobalID 0 0,First,#,{process_points_layer.name},GlobalID,-1,-1;' + \
        fr'Class "סיווג" true true false 0 Short 0 0,First,#,{process_points_layer.name},Class,-1,-1;' + \
        fr'DataSource "מקור הנקודה" true false false 0 Short 0 0,First,#,{process_points_layer.name},DataSource,-1,-1;' + \
        fr'MarkCode "סימון" true false false 0 Short 0 0,First,#,{process_points_layer.name},MarkCode,-1,-1;' + \
        fr'IsControlBorder "נקודת גבול ובקרה" true false false 0 Short 0 0,First,#,{process_points_layer.name},IsControlBorder,-1,-1'


    Append(inputs=process_points_layer,target=record_points_layer,expression = query,field_mapping = field_mapping,
        schema_type="NO_TEST",subtype="",match_fields=None,update_geometry="NOT_UPDATE_GEOMETRY")
    reopen_map()

    SelectByAttribute(record_points_layer,where_clause=f""" CreatedByRecord = '{Process_GUID}' """,selection_type="NEW SELECTION")
    appended_features_count = int(GetCount(record_points_layer).getOutput(0))
    SelectByAttribute(record_points_layer, "CLEAR_SELECTION")

    inserted_points = SelectByAttribute(record_points_layer,where_clause=f""" CreatedByRecord = '{Process_GUID}' """,selection_type='NEW_SELECTION')

    calculated_features_count = int(GetCount(inserted_points)[0])
    
    CalculateField(in_table=inserted_points,field="CreatedByRecord",expression=f"'{RecordGUID}'",
        expression_type="SQL",code_block="",field_type="TEXT",enforce_domains="NO_ENFORCE_DOMAINS")
    

    return appended_features_count, calculated_features_count
